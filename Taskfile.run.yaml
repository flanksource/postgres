version: "3"

# GitHub Actions output grouping - disabled in container
# output:
#   group:
#     begin: "::group::{{.TASK}}"
#     end: "::endgroup::"

# Global environment variables for PostgreSQL paths
env:
  PG14BIN: /usr/lib/postgresql/14/bin
  PG15BIN: /usr/lib/postgresql/15/bin
  PG16BIN: /usr/lib/postgresql/16/bin
  PG17BIN: /usr/lib/postgresql/17/bin
  # Helper function to run commands as postgres user when root
  RUN_AS_POSTGRES: 'if [ "$(id -u)" = "0" ]; then gosu postgres; fi'

tasks:
  detect-current-version:
    desc: Detect current PostgreSQL version from data directory
    silent: true
    cmds:
      - cmd: |
          if [ -f "/var/lib/postgresql/data/PG_VERSION" ]; then
            cat /var/lib/postgresql/data/PG_VERSION
          else
            echo "0"
          fi
        silent: true

  detect-target-version:
    desc: Detect target PostgreSQL version from PG_VERSION env var (default 17)
    silent: true
    cmds:
      - cmd: echo "${PG_VERSION:-17}"
        silent: true

  reset-password:
    desc: Reset PostgreSQL password if RESET_PASSWORD=true
    silent: true
    vars:
      CURRENT_VERSION:
        sh: task run:detect-current-version
    status:
      - test "$RESET_PASSWORD" != "true"
    cmds:
      - |
        if [ "{{.CURRENT_VERSION}}" = "0" ]; then
          echo "ERROR: No PostgreSQL data found, cannot reset password"
          exit 1
        fi

        echo "üîë Resetting PostgreSQL password..."

        # Start PostgreSQL temporarily for password reset
        echo "Starting PostgreSQL {{.CURRENT_VERSION}} temporarily for password reset..."
        echo "Running: /usr/lib/postgresql/{{.CURRENT_VERSION}}/bin/pg_ctl -D /var/lib/postgresql/data -l /tmp/postgres-reset.log -o '-p 5433' start"
        /usr/lib/postgresql/{{.CURRENT_VERSION}}/bin/pg_ctl \
          -D /var/lib/postgresql/data \
          -l /tmp/postgres-reset.log \
          -o "-p 5433" \
          start

        sleep 3

        # Reset password
        echo "Resetting password for user ${POSTGRES_USER:-postgres}..."
        echo "Running: /usr/lib/postgresql/{{.CURRENT_VERSION}}/bin/psql -p 5433 -c 'ALTER USER ...'"
        /usr/lib/postgresql/{{.CURRENT_VERSION}}/bin/psql \
          -p 5433 \
          -c "ALTER USER ${POSTGRES_USER:-postgres} PASSWORD '${POSTGRES_PASSWORD}';"

        # Stop PostgreSQL
        echo "Stopping PostgreSQL..."
        echo "Running: /usr/lib/postgresql/{{.CURRENT_VERSION}}/bin/pg_ctl -D /var/lib/postgresql/data stop"
        /usr/lib/postgresql/{{.CURRENT_VERSION}}/bin/pg_ctl \
          -D /var/lib/postgresql/data \
          stop

        echo "‚úÖ Password reset completed"

  auto-upgrade:
    desc: Auto-detect current version and upgrade to PG_VERSION target (with password reset if needed)
    silent: true
    cmds:
      - |
        # Detect versions without group markers
        if [ -f "/var/lib/postgresql/data/PG_VERSION" ]; then
          CURRENT_VERSION=$(cat /var/lib/postgresql/data/PG_VERSION)
        else
          CURRENT_VERSION=0
        fi

        TARGET_VERSION="${PG_VERSION:-17}"

        echo "üîç PostgreSQL Auto-Upgrade Detection"
        echo "Current version: $CURRENT_VERSION"
        echo "Target version:  $TARGET_VERSION"

        if [ "$CURRENT_VERSION" = "0" ]; then
          echo "‚ùå No PostgreSQL data found in /var/lib/postgresql/data"
          echo "Please mount a volume with existing PostgreSQL data"
          exit 1
        fi

        if [ "$CURRENT_VERSION" -ge "$TARGET_VERSION" ]; then
          echo "‚úÖ PostgreSQL $CURRENT_VERSION is already at or above target version $TARGET_VERSION"

          # Handle password reset for existing installation
          if [ "$RESET_PASSWORD" = "true" ]; then
            task run:reset-password
          fi

          # Start PostgreSQL if requested
          if [ "$START_POSTGRES" = "true" ]; then
            echo "üöÄ Starting PostgreSQL $CURRENT_VERSION..."
            exec /usr/lib/postgresql/$CURRENT_VERSION/bin/postgres -D /var/lib/postgresql/data
          else
            echo "‚úÖ Upgrade verification complete. Set START_POSTGRES=true to start PostgreSQL."
            exit 0
          fi
        fi

        # Validate versions
        if [ "$CURRENT_VERSION" -lt 14 ] || [ "$TARGET_VERSION" -gt 17 ]; then
          echo "‚ùå Invalid version range. Current: $CURRENT_VERSION, Target: $TARGET_VERSION"
          echo "Supported versions: 14-17"
          exit 1
        fi

        echo "üöÄ Starting upgrade from PostgreSQL $CURRENT_VERSION to $TARGET_VERSION"

        # Check if auto-upgrade is disabled
        if [ "$AUTO_UPGRADE" = "false" ]; then
          echo "‚ö†Ô∏è  Auto-upgrade disabled."
          if [ "$START_POSTGRES" = "true" ]; then
            echo "üöÄ Starting PostgreSQL $CURRENT_VERSION without upgrade..."
            exec /usr/lib/postgresql/$CURRENT_VERSION/bin/postgres -D /var/lib/postgresql/data
          else
            echo "‚úÖ Ready to start PostgreSQL $CURRENT_VERSION. Set START_POSTGRES=true to start."
            exit 0
          fi
        fi

        # Setup working directory for upgrade - pg_upgrade needs specific structure
        echo "üì¶ Setting up upgrade environment..."

        # Create backup directory inside data folder
        mkdir -p /var/lib/postgresql/data/backups

        # Move all contents EXCEPT backups directory to backup location
        echo "Moving existing PostgreSQL $CURRENT_VERSION data to backup location..."
        mkdir -p /var/lib/postgresql/data/backups/data-$CURRENT_VERSION

        # Move all files and directories except 'backups'
        for item in /var/lib/postgresql/data/*; do
          basename=$(basename "$item")
          if [ "$basename" != "backups" ] && [ -e "$item" ]; then
            mv "$item" /var/lib/postgresql/data/backups/data-$CURRENT_VERSION/
          fi
        done

        # Move hidden files too (except . and ..)
        for item in /var/lib/postgresql/data/.[^.]*; do
          if [ -e "$item" ]; then
            mv "$item" /var/lib/postgresql/data/backups/data-$CURRENT_VERSION/
          fi
        done 2>/dev/null || true

        # Create upgrade directory structure inside data volume
        mkdir -p /var/lib/postgresql/data/upgrades

        # Restore backup data to main location for the first upgrade
        echo "Restoring backup data to main location for upgrade..."
        cp -a /var/lib/postgresql/data/backups/data-$CURRENT_VERSION/* /var/lib/postgresql/data/
        cp -a /var/lib/postgresql/data/backups/data-$CURRENT_VERSION/.[^.]* /var/lib/postgresql/data/ 2>/dev/null || true

        # Perform sequential upgrades
        current=$CURRENT_VERSION
        target=$TARGET_VERSION

        while [ $current -lt $target ]; do
          next=$((current + 1))
          echo "========================================="
          echo "Upgrading from PostgreSQL $current to $next"
          echo "========================================="

          # Now data is available in /var/lib/postgresql/data for upgrade
          FROM=$current TO=$next task run:upgrade-single

          # After upgrade, move new version data back to main location
          if [ -d "/var/lib/postgresql/data/upgrades/$next" ]; then
            echo "Moving PostgreSQL $next data to main location..."
            # Clear main data directory (except backups and upgrades)
            for item in /var/lib/postgresql/data/*; do
              basename=$(basename "$item")
              if [ "$basename" != "backups" ] && [ "$basename" != "upgrades" ] && [ -e "$item" ]; then
                rm -rf "$item"
              fi
            done
            # Move hidden files too
            for item in /var/lib/postgresql/data/.[^.]*; do
              if [ -e "$item" ] && [ "$(basename "$item")" != "." ] && [ "$(basename "$item")" != ".." ]; then
                rm -rf "$item"
              fi
            done 2>/dev/null || true
            
            # Move upgraded data
            mv /var/lib/postgresql/data/upgrades/$next/* /var/lib/postgresql/data/
            mv /var/lib/postgresql/data/upgrades/$next/.[^.]* /var/lib/postgresql/data/ 2>/dev/null || true
            rm -rf /var/lib/postgresql/data/upgrades/$next
          fi

          current=$next
        done

        # Clean up upgrade directories but keep backups
        rm -rf /var/lib/postgresql/data/upgrades
        echo "‚úÖ Original data preserved in /var/lib/postgresql/data/backups/data-$CURRENT_VERSION"

        echo "üéâ All upgrades completed successfully!"
        echo "Final version: PostgreSQL $TARGET_VERSION"

        # Handle password reset after upgrade
        if [ "$RESET_PASSWORD" = "true" ]; then
          CURRENT_VERSION=$TARGET_VERSION task run:reset-password
        fi

        # Start PostgreSQL if requested
        if [ "$START_POSTGRES" = "true" ]; then
          echo "üöÄ Starting PostgreSQL $TARGET_VERSION..."
          echo "üìã Logs will be directed to stderr for container visibility"
          exec /usr/lib/postgresql/$TARGET_VERSION/bin/postgres -D /var/lib/postgresql/data
        else
          echo "‚úÖ Upgrade complete. Set START_POSTGRES=true to start PostgreSQL $TARGET_VERSION."
          echo "üí° To manually start: /usr/lib/postgresql/$TARGET_VERSION/bin/postgres -D /var/lib/postgresql/data"
          exit 0
        fi

  sequential-upgrade:
    desc: Perform sequential upgrades from FROM to TO version
    silent: true
    vars:
      FROM: '{{.FROM | default (env "FROM")}}'
      TO: '{{.TO | default (env "TO")}}'
    cmds:
      - |
        # Create upgrade directory structure inside data volume
        mkdir -p /var/lib/postgresql/data/upgrades
        
        # Note: For sequential-upgrade, we assume data is already in the correct location
        # (either already in /var/lib/postgresql/data or restored by calling task)
        
        current={{.FROM}}
        target={{.TO}}

        while [ $current -lt $target ]; do
          next=$((current + 1))
          echo "========================================="
          echo "Upgrading from PostgreSQL $current to $next"
          echo "========================================="

          task run:upgrade-single FROM=$current TO=$next

          # After upgrade, move new version data back to main location for next iteration
          if [ -d "/var/lib/postgresql/data/upgrades/$next" ]; then
            echo "Moving PostgreSQL $next data to main location for next upgrade step..."
            # Clear main data directory (except backups and upgrades)
            for item in /var/lib/postgresql/data/*; do
              basename=$(basename "$item")
              if [ "$basename" != "backups" ] && [ "$basename" != "upgrades" ] && [ -e "$item" ]; then
                rm -rf "$item"
              fi
            done
            # Move hidden files too
            for item in /var/lib/postgresql/data/.[^.]*; do
              if [ -e "$item" ] && [ "$(basename "$item")" != "." ] && [ "$(basename "$item")" != ".." ]; then
                rm -rf "$item"
              fi
            done 2>/dev/null || true
            
            # Move upgraded data
            mv /var/lib/postgresql/data/upgrades/$next/* /var/lib/postgresql/data/
            mv /var/lib/postgresql/data/upgrades/$next/.[^.]* /var/lib/postgresql/data/ 2>/dev/null || true
            rm -rf /var/lib/postgresql/data/upgrades/$next
          fi

          current=$next
        done
        
        # Clean up upgrade directories
        rm -rf /var/lib/postgresql/data/upgrades

  upgrade-single:
    desc: Perform single PostgreSQL upgrade from {{.FROM}} to {{.TO}}
    silent: true
    vars:
      FROM: '{{.FROM | default (env "FROM")}}'
      TO: '{{.TO | default (env "TO")}}'
      PGBINOLD: /usr/lib/postgresql/{{.FROM}}/bin
      PGBINNEW: /usr/lib/postgresql/{{.TO}}/bin
      PGDATAOLD: /var/lib/postgresql/data
      PGDATANEW: /var/lib/postgresql/data/upgrades/{{.TO}}
    preconditions:
      - sh: "test {{.FROM}} -lt {{.TO}}"
        msg: "FROM version must be less than TO version"
    cmds:
      - |
        # Pre-upgrade check
        echo "üîç Running pre-upgrade checks for PostgreSQL {{.FROM}}..."

        if [ ! -f "{{.PGDATAOLD}}/PG_VERSION" ]; then
          echo "ERROR: No PostgreSQL {{.FROM}} cluster found at {{.PGDATAOLD}}"
          exit 1
        fi

        VERSION=$(cat "{{.PGDATAOLD}}/PG_VERSION")
        if [ "$VERSION" != "{{.FROM}}" ]; then
          echo "ERROR: Expected PostgreSQL {{.FROM}}, but found version $VERSION"
          exit 1
        fi

        echo "‚úÖ PostgreSQL {{.FROM}} cluster verified at {{.PGDATAOLD}}"

        # Ensure clean shutdown if needed
        if [ -f "{{.PGDATAOLD}}/postmaster.pid" ]; then
          echo "Stopping PostgreSQL {{.FROM}} for clean shutdown..."
          echo "Running: {{.PGBINOLD}}/pg_ctl -D {{.PGDATAOLD}} stop -m fast -w"
          {{.PGBINOLD}}/pg_ctl -D "{{.PGDATAOLD}}" stop -m fast -w || true
          sleep 2
        fi

        echo "=== Pre-upgrade cluster info for PostgreSQL {{.FROM}} ==="
        echo "Running: {{.PGBINOLD}}/pg_controldata {{.PGDATAOLD}}"
        {{.PGBINOLD}}/pg_controldata "{{.PGDATAOLD}}" | grep -E "(Database cluster state|Latest checkpoint location|Latest checkpoint's REDO location|Latest checkpoint's NextXID|Database system identifier|pg_control version|Catalog version)" || {
          echo "WARNING: Cannot read cluster state information"
        }

        {{.PGBINOLD}}/pg_controldata "{{.PGDATAOLD}}" | grep -q "Database cluster state.*shut down" || {
          echo "WARNING: Database cluster is not cleanly shut down"
        }

        echo "‚úÖ Pre-upgrade checks completed for PostgreSQL {{.FROM}}"

        # Initialize new cluster
        if [ ! -s "{{.PGDATANEW}}/PG_VERSION" ]; then
          echo "üîß Initializing PostgreSQL {{.TO}} cluster..."
          mkdir -p "{{.PGDATANEW}}"
          chown postgres:postgres "{{.PGDATANEW}}"
          echo "Running: {{.PGBINNEW}}/initdb -D {{.PGDATANEW}}"
          {{.PGBINNEW}}/initdb -D "{{.PGDATANEW}}"
          echo "‚úÖ PostgreSQL {{.TO}} cluster initialized"
        else
          echo "‚úÖ PostgreSQL {{.TO}} cluster already exists"
        fi

        # Run pg_upgrade
        echo "‚ö° Performing pg_upgrade from PostgreSQL {{.FROM}} to {{.TO}}..."
        cd /var/lib/postgresql

        # Check first to validate compatibility
        echo "Checking cluster compatibility..."
        echo "Running: {{.PGBINNEW}}/pg_upgrade --old-bindir={{.PGBINOLD}} --new-bindir={{.PGBINNEW}} --old-datadir={{.PGDATAOLD}} --new-datadir={{.PGDATANEW}} --check"
        {{.PGBINNEW}}/pg_upgrade \
          --old-bindir="{{.PGBINOLD}}" \
          --new-bindir="{{.PGBINNEW}}" \
          --old-datadir="{{.PGDATAOLD}}" \
          --new-datadir="{{.PGDATANEW}}" \
          --check

        # Perform the actual upgrade
        echo "Performing upgrade..."
        echo "Running: {{.PGBINNEW}}/pg_upgrade --old-bindir={{.PGBINOLD}} --new-bindir={{.PGBINNEW}} --old-datadir={{.PGDATAOLD}} --new-datadir={{.PGDATANEW}}"
        {{.PGBINNEW}}/pg_upgrade \
          --old-bindir="{{.PGBINOLD}}" \
          --new-bindir="{{.PGBINNEW}}" \
          --old-datadir="{{.PGDATAOLD}}" \
          --new-datadir="{{.PGDATANEW}}"

        echo "‚úÖ pg_upgrade completed successfully"

        # Post-upgrade check
        echo "üîç Running post-upgrade checks for PostgreSQL {{.TO}}..."

        if [ ! -f "{{.PGDATANEW}}/PG_VERSION" ]; then
          echo "ERROR: No PostgreSQL {{.TO}} cluster found at {{.PGDATANEW}}"
          exit 1
        fi

        VERSION=$(cat "{{.PGDATANEW}}/PG_VERSION")
        if [ "$VERSION" != "{{.TO}}" ]; then
          echo "ERROR: Expected PostgreSQL {{.TO}}, but found version $VERSION"
          exit 1
        fi

        echo "‚úÖ PostgreSQL {{.TO}} cluster verified at {{.PGDATANEW}}"

        echo "=== Post-upgrade cluster info for PostgreSQL {{.TO}} ==="
        echo "Running: {{.PGBINNEW}}/pg_controldata {{.PGDATANEW}}"
        {{.PGBINNEW}}/pg_controldata "{{.PGDATANEW}}" | grep -E "(Database cluster state|Latest checkpoint location|Latest checkpoint's REDO location|Latest checkpoint's NextXID|Database system identifier|pg_control version|Catalog version)" || {
          echo "ERROR: Cannot read control data from upgraded cluster"
          exit 1
        }

        if [ ! -f "{{.PGDATANEW}}/postgresql.conf" ] || [ ! -f "{{.PGDATANEW}}/pg_hba.conf" ]; then
          echo "ERROR: Missing configuration files in upgraded cluster"
          exit 1
        fi

        echo "‚úÖ Post-upgrade checks completed for PostgreSQL {{.TO}}"
        echo "‚úÖ Upgrade from PostgreSQL {{.FROM}} to {{.TO}} completed successfully!"

  upgrade-from-env:
    desc: Upgrade using FROM and TO environment variables (for container entrypoint)
    silent: true
    vars:
      FROM: '{{.FROM | default (env "FROM")}}'
      TO: '{{.TO | default (env "TO")}}'
    cmds:
      - task: upgrade-single
        vars:
          FROM: "{{.FROM}}"
          TO: "{{.TO}}"

  pre-upgrade-check:
    desc: Run pre-upgrade checks for PostgreSQL {{.FROM}} to {{.TO}}
    silent: true
    cmds:
      - |
        echo "üîç Running pre-upgrade checks for PostgreSQL {{.FROM}}..."

        # Check if old cluster exists and is valid
        if [ ! -f "{{.PGDATAOLD}}/PG_VERSION" ]; then
          echo "ERROR: No PostgreSQL {{.FROM}} cluster found at {{.PGDATAOLD}}"
          exit 1
        fi

        # Verify PostgreSQL version
        VERSION=$(cat "{{.PGDATAOLD}}/PG_VERSION")
        if [ "$VERSION" != "{{.FROM}}" ]; then
          echo "ERROR: Expected PostgreSQL {{.FROM}}, but found version $VERSION"
          exit 1
        fi

        echo "‚úÖ PostgreSQL {{.FROM}} cluster verified at {{.PGDATAOLD}}"

        # Ensure clean shutdown if needed
        if [ -f "{{.PGDATAOLD}}/postmaster.pid" ]; then
          echo "Stopping PostgreSQL {{.FROM}} for clean shutdown..."
          echo "Running: {{.PGBINOLD}}/pg_ctl -D {{.PGDATAOLD}} stop -m fast -w"
          {{.PGBINOLD}}/pg_ctl -D "{{.PGDATAOLD}}" stop -m fast -w || true
          sleep 2
        fi

        # Check cluster health with comprehensive logging
        echo "=== Cluster state for PostgreSQL {{.FROM}} ==="
        echo "Running: {{.PGBINOLD}}/pg_controldata {{.PGDATAOLD}}"
        {{.PGBINOLD}}/pg_controldata "{{.PGDATAOLD}}" | grep -E "(Database cluster state|Latest checkpoint location|Latest checkpoint's REDO location|Latest checkpoint's NextXID|Database system identifier)" || {
          echo "WARNING: Cannot read cluster state information"
        }

        {{.PGBINOLD}}/pg_controldata "{{.PGDATAOLD}}" | grep -q "Database cluster state.*shut down" || {
          echo "WARNING: Database cluster is not cleanly shut down"
        }

        echo "‚úÖ Pre-upgrade checks completed for PostgreSQL {{.FROM}}"

  init-new-cluster:
    desc: Initialize new PostgreSQL {{.TO}} cluster if needed
    silent: true
    status:
      - test -s "{{.PGDATANEW}}/PG_VERSION"
    cmds:
      - |
        echo "üîß Initializing PostgreSQL {{.TO}} cluster..."
        mkdir -p "{{.PGDATANEW}}"
        chown postgres:postgres "{{.PGDATANEW}}"
        echo "Running: {{.PGBINNEW}}/initdb -D {{.PGDATANEW}}"
        {{.PGBINNEW}}/initdb -D "{{.PGDATANEW}}"
        echo "‚úÖ PostgreSQL {{.TO}} cluster initialized"

  run-pg-upgrade:
    desc: Run pg_upgrade from PostgreSQL {{.FROM}} to {{.TO}}
    cmds:
      - |
        echo "‚ö° Performing pg_upgrade from PostgreSQL {{.FROM}} to {{.TO}}..."
        cd /var/lib/postgresql

        # Create socket directory and set permissions
        mkdir -p /var/run/postgresql
        chown postgres:postgres /var/run/postgresql
        chmod 755 /var/run/postgresql

        # Run pg_upgrade check first
        echo "Running: {{.PGBINNEW}}/pg_upgrade --old-bindir={{.PGBINOLD}} --new-bindir={{.PGBINNEW}} --old-datadir={{.PGDATAOLD}} --new-datadir={{.PGDATANEW}} --socketdir=/var/run/postgresql --check"
        {{.PGBINNEW}}/pg_upgrade \
          --old-bindir="{{.PGBINOLD}}" \
          --new-bindir="{{.PGBINNEW}}" \
          --old-datadir="{{.PGDATAOLD}}" \
          --new-datadir="{{.PGDATANEW}}" \
          --socketdir=/var/run/postgresql \
          --check

        # If check passes, run the actual upgrade
        echo "Running: {{.PGBINNEW}}/pg_upgrade --old-bindir={{.PGBINOLD}} --new-bindir={{.PGBINNEW}} --old-datadir={{.PGDATAOLD}} --new-datadir={{.PGDATANEW}} --socketdir=/var/run/postgresql"
        {{.PGBINNEW}}/pg_upgrade \
          --old-bindir="{{.PGBINOLD}}" \
          --new-bindir="{{.PGBINNEW}}" \
          --old-datadir="{{.PGDATAOLD}}" \
          --new-datadir="{{.PGDATANEW}}" \
          --socketdir=/var/run/postgresql

        echo "‚úÖ pg_upgrade completed successfully"

  post-upgrade-check:
    desc: Run post-upgrade checks for PostgreSQL {{.TO}}
    silent: true
    cmds:
      - |
        echo "üîç Running post-upgrade checks for PostgreSQL {{.TO}}..."

        # Check if new cluster exists
        if [ ! -f "{{.PGDATANEW}}/PG_VERSION" ]; then
          echo "ERROR: No PostgreSQL {{.TO}} cluster found at {{.PGDATANEW}}"
          exit 1
        fi

        # Verify PostgreSQL version
        VERSION=$(cat "{{.PGDATANEW}}/PG_VERSION")
        if [ "$VERSION" != "{{.TO}}" ]; then
          echo "ERROR: Expected PostgreSQL {{.TO}}, but found version $VERSION"
          exit 1
        fi

        echo "‚úÖ PostgreSQL {{.TO}} cluster verified at {{.PGDATANEW}}"

        # Verify cluster data without starting the server
        echo "Verifying upgraded cluster data..."

        # Check control data with comprehensive logging
        echo "=== Post-upgrade cluster verification for PostgreSQL {{.TO}} ==="
        echo "Running: {{.PGBINNEW}}/pg_controldata {{.PGDATANEW}}"
        {{.PGBINNEW}}/pg_controldata "{{.PGDATANEW}}" | grep -E "(Database cluster state|Latest checkpoint location|Latest checkpoint's REDO location|Latest checkpoint's NextXID|Database system identifier|pg_control version|Catalog version)" || {
          echo "ERROR: Cannot read control data from upgraded cluster"
          exit 1
        }

        # Verify basic file structure
        if [ ! -f "{{.PGDATANEW}}/postgresql.conf" ] || [ ! -f "{{.PGDATANEW}}/pg_hba.conf" ]; then
          echo "ERROR: Missing configuration files in upgraded cluster"
          exit 1
        fi

        echo "NOTE: Full database verification skipped in container environment"
        echo "To verify the upgrade, start PostgreSQL {{.TO}} and run:"
        echo "  - SELECT version();"
        echo "  - \\l to list databases"
        echo "  - vacuumdb -a -z"

        echo "‚úÖ Post-upgrade checks completed for PostgreSQL {{.TO}}"

  # Extension management tasks for container runtime
  init-extensions:
    desc: Initialize PostgreSQL extensions from POSTGRES_EXTENSIONS environment variable
    silent: false
    cmds:
      - |
        if [ -z "$POSTGRES_EXTENSIONS" ]; then
          echo "No extensions specified in POSTGRES_EXTENSIONS environment variable"
          exit 0
        fi
        
        echo "Initializing PostgreSQL extensions: $POSTGRES_EXTENSIONS"
        
        # Create extension marker file
        echo "$POSTGRES_EXTENSIONS" > /var/lib/postgresql/.extensions_to_install
        
        echo "Extensions marked for installation. They will be installed when PostgreSQL starts."

  # Service management tasks
  start-s6-services:
    desc: Start all s6-overlay services
    silent: false
    cmds:
      - |
        if [ ! -d "/var/run/s6" ]; then
          echo "s6-overlay not detected, starting PostgreSQL directly"
          exec postgres -D /var/lib/postgresql/data/pgdata
        else
          echo "Starting s6-overlay services..."
          exec /init
        fi

  check-service-health:
    desc: Check health of PostgreSQL and optional services
    silent: false
    cmds:
      - |
        echo "Checking PostgreSQL health..."
        pg_isready -h localhost -p 5432 -U ${POSTGRES_USER:-postgres} || {
          echo "PostgreSQL is not ready"
          exit 1
        }
        echo "‚úÖ PostgreSQL is healthy"
        
        # Check PgBouncer if enabled
        if [ "${PGBOUNCER_ENABLED:-false}" = "true" ]; then
          echo "Checking PgBouncer health..."
          nc -z localhost ${PGBOUNCER_PORT:-6432} || {
            echo "‚ùå PgBouncer is not responding"
            exit 1
          }
          echo "‚úÖ PgBouncer is healthy"
        fi
        
        # Check PostgREST if enabled
        if [ "${POSTGREST_ENABLED:-false}" = "true" ]; then
          echo "Checking PostgREST health..."
          curl -f -s http://localhost:${POSTGREST_SERVER_PORT:-3000}/ >/dev/null || {
            echo "‚ùå PostgREST is not responding"
            exit 1
          }
          echo "‚úÖ PostgREST is healthy"
        fi
        
        echo "‚úÖ All enabled services are healthy"