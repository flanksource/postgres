package pgtune

import (
	"fmt"
	"time"

	"github.com/flanksource/clicky"
	"github.com/flanksource/commons/text"
	"github.com/flanksource/postgres/pkg/sysinfo"
	"github.com/flanksource/postgres/pkg/utils"
)

// OptimizeOptions contains options for optimizing PostgreSQL configuration
type OptimizeOptions struct {
	Enabled        bool
	DataDir        string
	DBType         string
	MaxConnections int
	MemoryMB       int
	Cores          int
	SystemInfo     *sysinfo.SystemInfo
}

// OptimizeAndSave calculates optimal PostgreSQL configuration and saves to postgresql.auto.conf
func OptimizeAndSave(opts OptimizeOptions) (string, error) {
	// Use provided system info or detect
	sysInfo := opts.SystemInfo
	if sysInfo == nil {
		var err error
		sysInfo, err = sysinfo.DetectSystemInfo()
		if err != nil {
			return "", fmt.Errorf("failed to detect system info: %w", err)
		}
	}

	clicky.Infof("ðŸ”§ Running pg_tune to optimize configuration...")

	if opts.MemoryMB > 0 {
		currentMem := sysInfo.EffectiveMemory()
		clicky.Warnf("Overriding memory from %s to %s", text.HumanizeBytes(currentMem), text.HumanizeBytes(opts.MemoryMB*utils.MB))
		sysInfo.Container.Memory = uint64(opts.MemoryMB) * utils.MB
	}

	if opts.Cores > 0 {
		clicky.Warnf("Overriding CPU cores from %d to %d\n", sysInfo.System.CPUs, opts.Cores)
		sysInfo.Container.Millis = opts.Cores * 1000
		sysInfo.Container.CPUs = opts.Cores
	}
	clicky.Infof("Detected System: %s ", sysInfo.System.Pretty().ANSI())
	clicky.Infof("Detected Container: %s", sysInfo.Container.Pretty().ANSI())

	r := sysInfo.Container
	if r.Memory == 0 {
		r.Memory = sysInfo.System.Memory
	}

	if r.CPUs == 0 {
		r.CPUs = sysInfo.System.CPUs
	}

	config := &TuningConfig{
		Resources:         r,
		MaxConnections:    opts.MaxConnections,
		DBType:            opts.DBType,
		PostgreSQLVersion: sysInfo.PostgreSQLVersion,
		DiskType:          nil, // Use detected disk type
	}

	// Calculate optimal parameters
	params, err := CalculateOptimalConfig(config)
	if err != nil {
		return "", fmt.Errorf("failed to calculate optimal config: %w", err)
	}

	if params.MaxConnections == 0 {
		params.MaxConnections = GetRecommendedMaxConnections(opts.DBType)
	}

	// Generate postgresql.auto.conf content
	configContent := generateAutoConf(params, sysInfo)

	clicky.Infof("Optimized with shared_buffers: %s, cpus: %d", params.SharedBuffers, r.CPUs)

	return configContent, nil
}

// generateAutoConf generates postgresql.auto.conf content from tuned parameters
func generateAutoConf(params *TunedParameters, sysInfo *sysinfo.SystemInfo) string {
	var content string

	// Header
	content += "# PostgreSQL Auto Configuration\n"
	content += "# Generated by pg_tune\n"
	content += fmt.Sprintf("# Generated: %s\n", time.Now().Format("2006-01-02 15:04:05"))
	content += fmt.Sprintf("# System: %.1f GB RAM, %d CPUs (effective: %d CPUs)\n",
		sysInfo.TotalMemoryGB(), sysInfo.System.CPUs, sysInfo.EffectiveCPUCount())
	content += "#\n\n"

	conf, err := params.AsConf()
	if err != nil {
		panic(fmt.Sprintf("failed to convert tuned parameters to conf: %v", err))
	}

	content += conf.AsFile() + "\n"
	return content
}
