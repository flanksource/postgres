package pgtune

import (
	"fmt"
	"os"
	"path/filepath"
	"time"

	. "github.com/flanksource/commons/text"
	"github.com/flanksource/postgres/pkg/sysinfo"
	"github.com/flanksource/postgres/pkg/types"
	"github.com/flanksource/postgres/pkg/utils"
)

// OptimizeOptions contains options for optimizing PostgreSQL configuration
type OptimizeOptions struct {
	Enabled        bool
	DataDir        string
	DBType         string
	MaxConnections int
	MemoryMB       int
	Cores          int
	SystemInfo     *sysinfo.SystemInfo
}

// OptimizeAndSave calculates optimal PostgreSQL configuration and saves to postgresql.auto.conf
func OptimizeAndSave(opts OptimizeOptions) error {
	// Use provided system info or detect
	sysInfo := opts.SystemInfo
	if sysInfo == nil {
		var err error
		sysInfo, err = sysinfo.DetectSystemInfo()
		if err != nil {
			return fmt.Errorf("failed to detect system info: %w", err)
		}
	}

	// Calculate max connections if not specified
	maxConnections := opts.MaxConnections
	if opts.MaxConnections > 0 {
		fmt.Printf("Using provided max connections: %d\n", maxConnections)
	} else {
		maxConnections = GetRecommendedMaxConnections(opts.DBType)
		fmt.Printf("Calculated max connections for DB type %s: %d\n", opts.DBType, maxConnections)
	}

	if opts.MemoryMB > 0 {
		fmt.Printf("Overriding memory from %s to %s\n", HumanizeBytes(sysInfo.ContainerMemory), HumanizeBytes(opts.MemoryMB*utils.MB))
		sysInfo.ContainerMemory = uint64(opts.MemoryMB) * utils.MB
	} else if sysInfo.ContainerMemory > 0 {
		fmt.Printf("Detected container memory: %s\n", HumanizeBytes(sysInfo.ContainerMemory))
	} else {
		fmt.Printf("Detected total system memory: %s\n", HumanizeBytes(sysInfo.TotalMemoryBytes))
	}

	if opts.Cores > 0 {
		fmt.Printf("Overriding CPU cores from %d to %d\n", sysInfo.CPUCount, opts.Cores)
		sysInfo.CPUCount = opts.Cores
	} else {
		fmt.Printf("Detected CPU cores: %d\n", sysInfo.CPUCount)
	}

	// Create tuning config
	tuningConfig := &TuningConfig{
		SystemInfo:     sysInfo,
		MaxConnections: maxConnections,
		DBType:         opts.DBType,
	}

	// Calculate optimal parameters
	params, err := CalculateOptimalConfig(tuningConfig)
	if err != nil {
		return fmt.Errorf("failed to calculate optimal config: %w", err)
	}

	// Generate postgresql.auto.conf content
	configContent := generateAutoConf(params, sysInfo)

	// Save to postgresql.auto.conf
	configPath := filepath.Join(opts.DataDir, "postgresql.auto.conf")
	if err := os.WriteFile(configPath, []byte(configContent), 0644); err != nil {
		return fmt.Errorf("failed to write postgresql.auto.conf: %w", err)
	}

	return nil
}

// generateAutoConf generates postgresql.auto.conf content from tuned parameters
func generateAutoConf(params *TunedParameters, sysInfo *sysinfo.SystemInfo) string {
	var content string

	// Header
	content += "# PostgreSQL Auto Configuration\n"
	content += "# Generated by pg_tune\n"
	content += fmt.Sprintf("# Generated: %s\n", time.Now().Format("2006-01-02 15:04:05"))
	content += fmt.Sprintf("# System: %.1f GB RAM, %d CPUs\n", sysInfo.TotalMemoryGB(), sysInfo.CPUCount)
	content += "#\n\n"

	// Memory Configuration
	content += "# Memory Configuration\n"
	content += fmt.Sprintf("max_connections = %d\n", params.MaxConnections)

	sharedBuffers := types.Size(utils.KBToBytes(params.SharedBuffers))
	content += fmt.Sprintf("shared_buffers = %s\n", sharedBuffers.PostgreSQLMB())

	effectiveCacheSize := types.Size(utils.KBToBytes(params.EffectiveCacheSize))
	content += fmt.Sprintf("effective_cache_size = %s\n", effectiveCacheSize.PostgreSQLMB())

	maintenanceWorkMem := types.Size(utils.KBToBytes(params.MaintenanceWorkMem))
	content += fmt.Sprintf("maintenance_work_mem = %s\n", maintenanceWorkMem.PostgreSQLMB())

	workMem := types.Size(utils.KBToBytes(params.WorkMem))
	content += fmt.Sprintf("work_mem = %s\n\n", workMem.PostgreSQLMB())

	// WAL Configuration
	content += "# WAL Configuration\n"
	walBuffers := types.Size(utils.KBToBytes(params.WalBuffers))
	content += fmt.Sprintf("wal_buffers = %s\n", walBuffers.PostgreSQLMB())

	minWalSize := types.Size(utils.KBToBytes(params.MinWalSize))
	content += fmt.Sprintf("min_wal_size = %s\n", minWalSize.PostgreSQLMB())

	maxWalSize := types.Size(utils.KBToBytes(params.MaxWalSize))
	content += fmt.Sprintf("max_wal_size = %s\n", maxWalSize.PostgreSQLMB())

	content += fmt.Sprintf("checkpoint_completion_target = %.2f\n", params.CheckpointCompletionTarget)
	content += fmt.Sprintf("wal_level = %s\n", params.WalLevel)

	if params.MaxWalSenders != nil {
		content += fmt.Sprintf("max_wal_senders = %d\n", *params.MaxWalSenders)
	}
	content += "\n"

	// Query Tuning
	content += "# Query Tuning\n"
	content += fmt.Sprintf("random_page_cost = %.1f\n", params.RandomPageCost)

	if params.EffectiveIoConcurrency != nil {
		content += fmt.Sprintf("effective_io_concurrency = %d\n", *params.EffectiveIoConcurrency)
	}

	content += fmt.Sprintf("default_statistics_target = %d\n\n", params.DefaultStatisticsTarget)

	// Parallel Processing
	content += "# Parallel Processing\n"
	content += fmt.Sprintf("max_worker_processes = %d\n", params.MaxWorkerProcesses)
	content += fmt.Sprintf("max_parallel_workers = %d\n", params.MaxParallelWorkers)
	content += fmt.Sprintf("max_parallel_workers_per_gather = %d\n", params.MaxParallelWorkersPerGather)

	if params.MaxParallelMaintenanceWorkers != nil {
		content += fmt.Sprintf("max_parallel_maintenance_workers = %d\n", *params.MaxParallelMaintenanceWorkers)
	}
	content += "\n"

	// Huge Pages
	content += "# Memory\n"
	content += fmt.Sprintf("huge_pages = %s\n", params.HugePages)

	return content
}
