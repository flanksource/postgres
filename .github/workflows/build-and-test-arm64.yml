name: Build and Test PostgreSQL Upgrade Container (ARM64)

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/postgres-upgrade

jobs:
  build-arm64:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to the Container registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha

      - name: Build Docker image for PR (ARM64)
        if: github.event_name == 'pull_request'
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/arm64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: |
            type=gha,scope=arm64
            type=gha,scope=multiplatform
          cache-to: type=gha,mode=max,scope=arm64
          outputs: type=docker,dest=/tmp/image-arm64.tar

      - name: Upload ARM64 image artifact for PR
        if: github.event_name == 'pull_request'
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-arm64
          path: /tmp/image-arm64.tar
          retention-days: 1

  test-arm64:
    needs: build-arm64
    runs-on: ubuntu-latest
    name: Test ARM64 - 14 to 17 (full upgrade)
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Download image artifact for PR
        if: github.event_name == 'pull_request'
        uses: actions/download-artifact@v4
        with:
          name: docker-image-arm64
          path: /tmp

      - name: Load image from artifact for PR
        if: github.event_name == 'pull_request'
        run: |
          docker load --input /tmp/image-arm64.tar
          echo "Loaded ARM64 image from artifact"
          docker images

          # Get the loaded image name and retag it to :main for consistency
          LOADED_IMAGE=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "${{ env.IMAGE_NAME }}" | head -n 1)
          echo "Loaded image: $LOADED_IMAGE"
          docker tag $LOADED_IMAGE ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:main
          echo "Retagged to: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:main"

      - name: Set image name
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "TEST_IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:pr-${{ github.event.pull_request.number }}" >> $GITHUB_ENV
          else
            echo "TEST_IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:main" >> $GITHUB_ENV
          fi

      - name: Pull test image
        if: github.event_name != 'pull_request'
        run: |
          echo "Pulling test image: ${{ env.TEST_IMAGE }}"
          docker pull ${{ env.TEST_IMAGE }}

      - name: Create test data directory
        run: |
          mkdir -p test-data/14
          chmod 777 test-data/14
          # Set SELinux context to allow Docker access
          sudo chcon -Rt svirt_sandbox_file_t test-data/ 2>/dev/null || true

      - name: Initialize PostgreSQL 14 with test data
        run: |
          docker run --rm \
            -v $PWD/test-data/14:/var/lib/postgresql/data \
            -e POSTGRES_PASSWORD=testpass \
            -e POSTGRES_DB=testdb \
            postgres:14-bookworm \
            bash -c "
              docker-entrypoint.sh postgres &
              PGPID=\$!
              sleep 10

              # Create testuser and test database
              psql -U postgres -d testdb <<EOF
          CREATE USER testuser WITH PASSWORD 'testpass';
          GRANT ALL PRIVILEGES ON DATABASE testdb TO testuser;
          GRANT ALL ON SCHEMA public TO testuser;
          GRANT CREATE ON SCHEMA public TO testuser;
          EOF

              # Create test data as testuser
              psql -U testuser -d testdb <<EOF
          CREATE TABLE test_data (
            id SERIAL PRIMARY KEY,
            data TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          );

          INSERT INTO test_data (data)
          SELECT 'Test record ' || generate_series(1, 1000);

          CREATE INDEX idx_test_data ON test_data(created_at);

          SELECT COUNT(*) as record_count FROM test_data;
          EOF

              # Gracefully stop PostgreSQL
              su postgres -c 'pg_ctl -D /var/lib/postgresql/data stop -m smart -w'
              sleep 5

              # Fix permissions for GitHub Actions runner
              chown -R 999:999 /var/lib/postgresql/data
            "

      - name: Run upgrade from 14 to 17
        timeout-minutes: 10
        run: |
          CONTAINER_ID=$(docker run -d \
            --platform linux/arm64 \
            -v $PWD/test-data/14:/var/lib/postgresql/data \
            -e POSTGRES_INITDB_ARGS="--auth-local=trust --auth-host=md5" \
            -e PG_VERSION=17 \
            ${{ env.TEST_IMAGE }})
          sleep 60
          docker stop -t 10 $CONTAINER_ID 2>/dev/null || true
          docker rm $CONTAINER_ID 2>/dev/null || true
          exit 0

      - name: Verify upgraded data
        run: |
          docker run --rm \
            -v $PWD/test-data/14:/var/lib/postgresql/data \
            -e POSTGRES_PASSWORD=testpass \
            postgres:17-bookworm \
            bash -c "
              docker-entrypoint.sh postgres &
              PGPID=\$!
              sleep 10

              # Verify data
              psql -U testuser -d testdb <<EOF
          -- Check table exists
          SELECT COUNT(*) as record_count FROM test_data;

          -- Check index exists
          SELECT indexname FROM pg_indexes WHERE tablename = 'test_data';

          -- Verify data integrity
          SELECT
            CASE
              WHEN COUNT(*) = 1000 THEN 'PASS: All records present'
              ELSE 'FAIL: Expected 1000 records, found ' || COUNT(*)
            END as result
          FROM test_data;
          EOF

              # Stop PostgreSQL
              pg_ctl -D /var/lib/postgresql/data stop -m smart -w

              # Fix permissions for GitHub Actions runner
              chown -R $(id -u):$(id -g) /var/lib/postgresql/data
            "

      - name: Fix permissions after test
        if: always()
        run: |
          # Always fix permissions after test, regardless of success/failure
          sudo chown -R $USER:$USER test-data/ || true

      - name: Collect and show test artifacts on failure
        if: failure()
        run: |
          echo "=== Test failed, collecting available information ==="

          # Try to fix permissions first
          sudo chown -R $USER:$USER test-data/ || true

          # Show directory structure
          echo "Test data directory structure:"
          find test-data/ -type f -name "*.log" 2>/dev/null || echo "No log files found"

          # Show any pg_upgrade output if available
          find test-data/ -name "pg_upgrade_output.d" -type d 2>/dev/null | while read dir; do
            echo "=== Contents of $dir ==="
            ls -la "$dir" 2>/dev/null || echo "Cannot access $dir"
          done

          # Show recent log entries
          find test-data/ -name "*.log" -type f 2>/dev/null | head -5 | while read logfile; do
            echo "=== Last 20 lines of $logfile ==="
            tail -20 "$logfile" 2>/dev/null || echo "Cannot read $logfile"
          done
