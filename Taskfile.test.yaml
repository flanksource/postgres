version: "3"

# GitHub Actions output grouping
output:
  group:
    begin: "::group::{{.TASK}}"
    end: "::endgroup::"

vars:
  TEST_DIR: ./test
  GO_TEST_FLAGS: -v -timeout 30m
  POSTGRES_IMAGE: flanksource/postgres:test
  KIND_CLUSTER_NAME: postgres-ct-test
  KIND_KUBECONFIG: /tmp/postgres-ct-kubeconfig

tasks:
  # Docker image testing tasks
  test-image:
    desc: Build Docker image and run integration tests
    deps: [build]
    dir: "{{.TEST_DIR}}"
    cmds:
      - |
        echo "ðŸ§ª Running Docker image integration tests..."
        go test {{.GO_TEST_FLAGS}} -run TestPostgresIntegration

  # Integration testing tasks
  test-integration:
    desc: Run comprehensive integration tests
    dir: "{{.TEST_DIR}}"
    deps: [build]
    cmds:
      - |
        echo "ðŸ§ª Running comprehensive integration tests..."
        go test {{.GO_TEST_FLAGS}} -run TestPostgresIntegration

  test-extensions:
    desc: Test all PostgreSQL extensions functionality
    dir: "{{.TEST_DIR}}"
    deps: [build]
    cmds:
      - |
        echo "ðŸ§© Testing PostgreSQL extensions..."
        go test {{.GO_TEST_FLAGS}} -run "TestPostgresIntegration.*extension"

  test-services:
    desc: Test all integrated services (PgBouncer, PostgREST, WAL-G)
    dir: "{{.TEST_DIR}}"
    deps: [build]
    cmds:
      - |
        echo "âš™ï¸ Testing integrated services..."
        go test {{.GO_TEST_FLAGS}} -run "TestPostgresIntegration.*(PgBouncer|PostgREST|WAL)"

  test-enhanced:
    desc: Run enhanced integration tests (Kubernetes-based)
    dir: "{{.TEST_DIR}}"
    deps: [build]
    cmds:
      - |
        echo "ðŸš€ Running enhanced integration tests..."
        go test {{.GO_TEST_FLAGS}} -run TestEnhanced

  # Main test tasks using Go tests
  all:
    desc: Run all PostgreSQL tests (upgrades, integration, extensions)
    dir: "{{.TEST_DIR}}"
    deps: [build]
    cmds:
      - |
        echo "ðŸ§ª Running all PostgreSQL tests..."
        go test {{.GO_TEST_FLAGS}} -run TestPostgresUpgrade
        go test {{.GO_TEST_FLAGS}} -run TestPostgresIntegration
        go test {{.GO_TEST_FLAGS}} -run TestEnhanced

  all-upgrades:
    desc: Run all PostgreSQL upgrade tests only
    dir: "{{.TEST_DIR}}"
    deps: [build]
    cmds:
      - |
        echo "ðŸ§ª Running all PostgreSQL upgrade tests..."
        go test {{.GO_TEST_FLAGS}} -run TestPostgresUpgrade

  all-features:
    desc: Run all feature tests (extensions, services, integrations)
    deps: [test-integration, test-extensions, test-services, test-enhanced]
    cmds:
      - echo "âœ… All feature tests completed"

  upgrade-14-to-17:
    desc: Test upgrade from PostgreSQL 14 to 17
    dir: "{{.TEST_DIR}}"
    deps: [build]
    cmds:
      - |
        echo "ðŸ§ª Testing upgrade from PostgreSQL 14 to 17..."
        go test {{.GO_TEST_FLAGS}} -run "TestPostgresUpgrade/Upgrade_14_to_17"

  upgrade-15-to-17:
    desc: Test upgrade from PostgreSQL 15 to 17
    dir: "{{.TEST_DIR}}"
    deps: [build]
    cmds:
      - |
        echo "ðŸ§ª Testing upgrade from PostgreSQL 15 to 17..."
        go test {{.GO_TEST_FLAGS}} -run "TestPostgresUpgrade/Upgrade_15_to_17"

  upgrade-16-to-17:
    desc: Test upgrade from PostgreSQL 16 to 17
    dir: "{{.TEST_DIR}}"
    deps: [build]
    cmds:
      - |
        echo "ðŸ§ª Testing upgrade from PostgreSQL 16 to 17..."
        go test {{.GO_TEST_FLAGS}} -run "TestPostgresUpgrade/Upgrade_16_to_17"

  upgrade-15-to-16:
    desc: Test upgrade from PostgreSQL 15 to 16
    dir: "{{.TEST_DIR}}"
    deps: [build]
    cmds:
      - |
        echo "ðŸ§ª Testing upgrade from PostgreSQL 15 to 16..."
        go test {{.GO_TEST_FLAGS}} -run "TestPostgresUpgrade/Upgrade_15_to_16"

  # Quick test for development
  quick:
    desc: Quick development test (14 to 17 upgrade only)
    dir: "{{.TEST_DIR}}"
    deps: [build]
    cmds:
      - |
        echo "âš¡ Running quick test..."
        go test {{.GO_TEST_FLAGS}} -run TestPostgresUpgradeQuick

  # Build task
  build:
    desc: Build the flanksource/postgres Docker image
    cmds:
      - task build:build

  # Status task using Go test
  status:
    desc: Show status of volumes and images
    dir: "{{.TEST_DIR}}"
    cmds:
      - |
        echo "ðŸ“Š Checking Docker resources status..."
        go test {{.GO_TEST_FLAGS}} -run TestShowUpgradeStatus

  # Test coverage and reporting
  test-coverage:
    desc: Run tests with coverage report
    dir: "{{.TEST_DIR}}"
    deps: [build]
    cmds:
      - |
        echo "ðŸ“Š Running tests with coverage..."
        go test -coverprofile=coverage.out {{.GO_TEST_FLAGS}} ./...
        go tool cover -html=coverage.out -o coverage.html
        echo "âœ… Coverage report generated: test/coverage.html"

  test-report:
    desc: Generate test report
    dir: "{{.TEST_DIR}}"
    deps: [build]
    cmds:
      - |
        echo "ðŸ“Š Generating test report..."
        go test {{.GO_TEST_FLAGS}} -json ./... | tee test-report.json
        echo "âœ… Test report generated: test/test-report.json"

  # CI/CD specific tasks
  ci-test:
    desc: Run tests in CI environment
    dir: "{{.TEST_DIR}}"
    deps: [build]
    env:
      CI: "true"
    cmds:
      - |
        echo "ðŸ¤– Running tests in CI mode..."
        go test {{.GO_TEST_FLAGS}} -json ./... | tee test-results.json
        # Generate JUnit XML for CI systems
        go install github.com/jstemmer/go-junit-report/v2@latest
        cat test-results.json | go-junit-report -out junit.xml
        echo "âœ… Test results saved to test/junit.xml"

  # Clean task
  # Utility and maintenance tasks

  clean:
    desc: Clean up test resources and Docker volumes
    cmds:
      - |
        echo "ðŸ§¹ Cleaning up test resources..."
        docker stop postgres-integration-test postgres-upgrade-test || true
        docker rm postgres-integration-test postgres-upgrade-test || true
        docker volume prune -f --filter label=cleanup=test || true
        docker system prune -f || true
        echo "âœ… Cleanup completed"

  # Help task
  help:
    desc: Show available tasks and usage examples
    cmds:
      - task --list
      - |
        echo ""
        echo "ðŸ“š Usage Examples:"
        echo "  task test:all                    # Run all tests (upgrades + features)"
        echo "  task test:test-image             # Build and test Docker image"
        echo "  task test:test-integration       # Run integration tests"
        echo "  task test:test-extensions        # Test PostgreSQL extensions"
        echo "  task test:test-services          # Test integrated services"
        echo "  task test:clean                  # Clean up test resources"

  # Helm E2E testing tasks
  helm:e2e:
    desc: Run end-to-end Helm chart tests with kind cluster and chart-testing (ct)
    deps: [build]
    cmds:
      - |
        echo "ðŸš€ Starting Helm E2E tests with chart-testing (ct) and kind..."

        # Check prerequisites
        echo "ðŸ“‹ Checking prerequisites..."
        command -v ct >/dev/null 2>&1 || { echo "âŒ ct (chart-testing) not installed"; exit 1; }
        command -v kind >/dev/null 2>&1 || { echo "âŒ kind not installed"; exit 1; }
        command -v helm >/dev/null 2>&1 || { echo "âŒ helm not installed"; exit 1; }
        command -v kubectl >/dev/null 2>&1 || { echo "âŒ kubectl not installed"; exit 1; }

        # Variables
        CLUSTER_NAME="{{.KIND_CLUSTER_NAME}}"
        KUBECONFIG_PATH="{{.KIND_KUBECONFIG}}"
        IMAGE_NAME="{{.POSTGRES_IMAGE}}"

        # Check if cluster already exists
        if kind get clusters 2>/dev/null | grep -q "^${CLUSTER_NAME}$"; then
          echo "â™»ï¸  Reusing existing kind cluster: $CLUSTER_NAME"
          kind export kubeconfig --name "$CLUSTER_NAME" --kubeconfig "$KUBECONFIG_PATH"
        else
          echo "ðŸ”§ Creating new kind cluster: $CLUSTER_NAME..."
          kind create cluster \
            --name "$CLUSTER_NAME" \
            --kubeconfig "$KUBECONFIG_PATH" \
            --wait 60s
        fi

        # Export kubeconfig
        export KUBECONFIG="$KUBECONFIG_PATH"

        # Wait for cluster to be ready
        echo "â³ Waiting for cluster to be ready..."
        kubectl wait --for=condition=ready node --all --timeout=60s

        # Load local docker image into kind (if it exists)
        echo "ðŸ“¦ Loading local postgres image into kind cluster..."
        if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
          kind load docker-image "$IMAGE_NAME" --name "$CLUSTER_NAME"
          echo "âœ… Loaded image: $IMAGE_NAME"
        else
          echo "âš ï¸  Image not found: $IMAGE_NAME"
          echo "    Chart will use registry image or you can specify with: IMAGE=myimage:tag task test:helm:e2e"
        fi

        # Run chart-testing lint
        echo "ðŸ” Linting chart with ct..."
        ct lint \
          --config .github/ct.yaml \
          --charts chart/

        # Extract image tag from IMAGE_NAME variable
        IMAGE_TAG="${IMAGE_NAME##*:}"

        # Run chart-testing install
        echo "ðŸ“¦ Installing and testing chart with ct..."
        ct install \
          --config .github/ct.yaml \
          --charts chart/ \
          --helm-extra-set-args "--set=image.tag=${IMAGE_TAG} --set=resources.requests.memory=256Mi --set=resources.limits.memory=512Mi"

        # Additional verification
        echo "âœ… Verifying deployment..."
        kubectl get all -A
        kubectl get pvc -A

        echo "âœ… Helm E2E tests completed successfully!"
        echo "ðŸ’¡ Cluster kept running for inspection. To delete: task test:helm:e2e:clean"

  helm:e2e:quick:
    desc: Quick Helm E2E test (skip linting, reuse cluster)
    deps: [build]
    cmds:
      - |
        echo "âš¡ Running quick Helm E2E test..."

        CLUSTER_NAME="{{.KIND_CLUSTER_NAME}}"
        KUBECONFIG_PATH="{{.KIND_KUBECONFIG}}"
        IMAGE_NAME="{{.POSTGRES_IMAGE}}"

        # Check if cluster exists, create if not
        if kind get clusters 2>/dev/null | grep -q "^${CLUSTER_NAME}$"; then
          echo "â™»ï¸  Reusing existing kind cluster: $CLUSTER_NAME"
          kind export kubeconfig --name "$CLUSTER_NAME" --kubeconfig "$KUBECONFIG_PATH"
        else
          echo "ðŸ”§ Creating kind cluster..."
          kind create cluster --name "$CLUSTER_NAME" --kubeconfig "$KUBECONFIG_PATH" --wait 60s
        fi

        export KUBECONFIG="$KUBECONFIG_PATH"

        # Load image if exists
        if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
          echo "ðŸ“¦ Loading image: $IMAGE_NAME"
          kind load docker-image "$IMAGE_NAME" --name "$CLUSTER_NAME"
        fi

        # Extract image tag
        IMAGE_TAG="${IMAGE_NAME##*:}"

        # Cleanup previous test installation
        helm uninstall postgres-test 2>/dev/null || true
        kubectl delete pvc --all 2>/dev/null || true

        echo "ðŸ“¦ Installing chart..."
        helm install postgres-test ./chart \
          --set image.tag="${IMAGE_TAG}" \
          --set resources.requests.memory=256Mi \
          --set resources.limits.memory=512Mi \
          --wait --timeout=5m

        echo "ðŸ§ª Running helm tests..."
        helm test postgres-test --timeout=5m

        echo "âœ… Quick E2E test completed!"
        echo "ðŸ’¡ Cluster kept running. To clean: task test:helm:e2e:clean"

  helm:e2e:clean:
    desc: Delete the kind cluster used for helm e2e tests
    cmds:
      - |
        CLUSTER_NAME="{{.KIND_CLUSTER_NAME}}"
        KUBECONFIG_PATH="{{.KIND_KUBECONFIG}}"

        echo "ðŸ§¹ Cleaning up kind cluster: $CLUSTER_NAME..."
        kind delete cluster --name "$CLUSTER_NAME" 2>/dev/null || echo "Cluster already deleted"
        rm -f "$KUBECONFIG_PATH" 2>/dev/null || true
        echo "âœ… Cleanup complete"

  helm:e2e:reset:
    desc: Reset helm e2e test environment (delete and recreate cluster)
    cmds:
      - task: helm:e2e:clean
      - |
        echo "ðŸ”„ Creating fresh kind cluster..."
        CLUSTER_NAME="{{.KIND_CLUSTER_NAME}}"
        KUBECONFIG_PATH="{{.KIND_KUBECONFIG}}"

        kind create cluster \
          --name "$CLUSTER_NAME" \
          --kubeconfig "$KUBECONFIG_PATH" \
          --wait 60s

        echo "âœ… Fresh cluster ready: $CLUSTER_NAME"
